# ç”Ÿäº§éƒ¨ç½²CI/CD
name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # éƒ¨ç½²ä¸è¦å–æ¶ˆ

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Run quality assessment
      run: |
        python tests/quality_tests/test_retrieval_quality.py
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        QDRANT_URL: ${{ secrets.QDRANT_URL }}
        QDRANT_API_KEY: ${{ secrets.QDRANT_API_KEY }}
    
    - name: Check quality gate
      run: |
        if [ -f quality_results.json ]; then
          # Parse quality score from JSON
          SCORE=$(python -c "
        import json
        with open('quality_results.json', 'r') as f:
            data = json.load(f)
        print(data.get('avg_overall_score', 0))
        ")
          
          echo "Quality score: $SCORE"
          
          # Quality gate threshold: 0.7
          if (( $(echo "$SCORE >= 0.7" | bc -l) )); then
            echo "âœ… Quality gate passed!"
          else
            echo "âŒ Quality gate failed! Score: $SCORE < 0.7"
            exit 1
          fi
        else
          echo "âŒ Quality results not found!"
          exit 1
        fi

  deploy-staging:
    needs: quality-gate
    runs-on: ubuntu-latest
    environment: staging
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push Docker image
      run: |
        # Build image with staging tag
        docker build -t rag-chatbot:staging .
        
        # Tag with commit SHA for traceability
        docker tag rag-chatbot:staging rag-chatbot:${{ github.sha }}
        
        echo "ğŸ“¦ Docker image built successfully"
    
    - name: Deploy to staging
      run: |
        echo "ğŸš€ Deploying to staging environment..."
        
        # Create staging environment variables
        cat > .env.staging << EOF
        OPENAI_API_KEY=${{ secrets.STAGING_OPENAI_API_KEY }}
        QDRANT_URL=${{ secrets.STAGING_QDRANT_URL }}
        QDRANT_API_KEY=${{ secrets.STAGING_QDRANT_API_KEY }}
        CHAT_MODEL=gpt-4o-mini
        EMBEDDING_MODEL=text-embedding-ada-002
        EOF
        
        # Simulate deployment (replace with actual deployment script)
        echo "âœ… Staging deployment completed"
    
    - name: Health check staging
      run: |
        echo "ğŸ” Running staging health checks..."
        
        # Wait for service to start
        sleep 30
        
        # Basic health check (replace with actual health check endpoint)
        # curl -f http://staging.your-domain.com/health || exit 1
        
        echo "âœ… Staging health check passed"
    
    - name: Run staging tests
      run: |
        # Run smoke tests against staging
        echo "ğŸ§ª Running staging smoke tests..."
        
        # Replace with actual staging tests
        python -c "
        print('Testing staging deployment...')
        print('âœ… Basic functionality test passed')
        print('âœ… API connectivity test passed')
        print('âœ… Database connectivity test passed')
        "

  deploy-production:
    needs: [quality-gate, deploy-staging]
    runs-on: ubuntu-latest
    environment: production
    if: startsWith(github.ref, 'refs/tags/v') || github.event.inputs.environment == 'production'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build production image
      run: |
        # Build optimized production image
        docker build -t rag-chatbot:production .
        
        # Tag with version from git tag or commit
        if [[ ${{ github.ref }} == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
          docker tag rag-chatbot:production rag-chatbot:$VERSION
          echo "VERSION=$VERSION" >> $GITHUB_ENV
        else
          docker tag rag-chatbot:production rag-chatbot:latest
          echo "VERSION=latest" >> $GITHUB_ENV
        fi
        
        echo "ğŸ“¦ Production image built: $VERSION"
    
    - name: Pre-deployment backup
      run: |
        echo "ğŸ’¾ Creating pre-deployment backup..."
        
        # Create backup of current production state
        # Replace with actual backup commands
        echo "âœ… Backup completed"
    
    - name: Deploy to production
      run: |
        echo "ğŸš€ Deploying to production environment..."
        
        # Create production environment variables
        cat > .env.production << EOF
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        QDRANT_URL=${{ secrets.QDRANT_URL }}
        QDRANT_API_KEY=${{ secrets.QDRANT_API_KEY }}
        CHAT_MODEL=gpt-4o
        EMBEDDING_MODEL=text-embedding-ada-002
        EOF
        
        # Blue-green deployment simulation
        echo "ğŸ”„ Starting blue-green deployment..."
        
        # Deploy to green environment
        echo "ğŸ“± Deploying to green slot..."
        
        # Health check green environment
        echo "ğŸ” Health checking green environment..."
        
        # Switch traffic to green
        echo "ğŸ”€ Switching traffic to green environment..."
        
        echo "âœ… Production deployment completed"
    
    - name: Production health check
      run: |
        echo "ğŸ” Running production health checks..."
        
        # Wait for service to stabilize
        sleep 60
        
        # Comprehensive health checks
        python -c "
        import time
        
        print('ğŸ” Running comprehensive health checks...')
        
        # Simulate health checks
        health_checks = [
            'Application startup',
            'API endpoints',
            'Database connectivity', 
            'External service connectivity',
            'Memory usage',
            'Response time'
        ]
        
        for check in health_checks:
            print(f'   âœ… {check}: OK')
            time.sleep(1)
            
        print('ğŸ‰ All health checks passed!')
        "
    
    - name: Production smoke tests
      run: |
        echo "ğŸ§ª Running production smoke tests..."
        
        # Critical functionality tests
        python -c "
        print('ğŸ§ª Testing critical functionality...')
        print('   âœ… User can access the application')
        print('   âœ… Basic query processing works')
        print('   âœ… Document retrieval functions')
        print('   âœ… Answer generation working')
        print('ğŸ‰ All smoke tests passed!')
        "
    
    - name: Notify deployment success
      run: |
        echo "ğŸ“¢ Notifying deployment success..."
        
        # Send notification (Slack, email, etc.)
        echo "âœ… Production deployment notification sent"
        
        # Update deployment tracking
        echo "ğŸ“Š Deployment tracking updated"

  rollback:
    runs-on: ubuntu-latest
    if: failure() && (startsWith(github.ref, 'refs/tags/v') || github.event.inputs.environment == 'production')
    needs: [deploy-production]
    
    steps:
    - name: Emergency rollback
      run: |
        echo "ğŸš¨ EMERGENCY ROLLBACK INITIATED"
        
        # Rollback to previous version
        echo "âª Rolling back to previous version..."
        
        # Restore from backup
        echo "ğŸ’¾ Restoring from backup..."
        
        # Verify rollback success
        echo "ğŸ” Verifying rollback..."
        
        echo "âœ… Rollback completed successfully"
    
    - name: Notify rollback
      run: |
        echo "ğŸ“¢ Notifying rollback completion..."
        
        # Send urgent notification
        echo "ğŸš¨ URGENT: Production rollback completed" 